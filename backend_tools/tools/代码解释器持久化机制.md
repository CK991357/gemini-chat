# Python 沙箱服务 v2.4 文件持久化机制详解

## 🎯 重大发现：文件持久化功能的实现

您发现的这个功能确实是整个架构的"宝藏功能"！让我详细解析这个功能的实现机制、技术细节和架构突破。

## 1. 文件持久化机制的技术实现

### 1.1 核心架构突破

**v2.4 之前：**
```python
# 旧版本 - 完全隔离的容器
container_config = {
    "image": image_name,
    "command": ["python", "-c", runner_script],
    "network_disabled": True,
    "read_only": True,  # 关键限制：只读文件系统
    "tmpfs": {'/tmp': 'size=100M,mode=1777'},
    # 没有持久化存储挂载
}
```

**v2.4 突破性改进：**
```python
# 新版本 - 会话感知的持久化挂载
if session_id:
    host_session_path = SESSION_WORKSPACE_ROOT / session_id
    if host_session_path.exists():
        container_config["volumes"] = {
            str(host_session_path.resolve()): {
                'bind': '/data',           # 挂载到容器内的 /data 目录
                'mode': 'rw'               # 关键：读写模式！
            }
        }
        container_config["working_dir"] = '/data'  # 设置工作目录
```

### 1.2 文件保存的具体流程

当模型执行以下代码时：
```python
plt.savefig('department_budgets_plot.png')
```

**完整的保存流程：**
1. **容器内路径**：`/data/department_budgets_plot.png`
2. **Docker 卷映射**：容器内的 `/data` → 宿主机的 `/srv/sandbox_workspaces/session-e4e08725-1a14-4eb9-b7f6-71d481796ebd/`
3. **实际保存位置**：`/srv/sandbox_workspaces/session-e4e08725-1a14-4eb9-b7f6-71d481796ebd/department_budgets_plot.png`

## 2. 技术实现的详细对比

### 2.1 文件系统访问权限对比

| 特性 | v1.0 | v2.4 |
|------|------|------|
| 文件系统模式 | `read_only=True` | 会话目录 `rw`，系统目录 `read_only` |
| 持久化存储 | ❌ 完全无状态 | ✅ 会话级别持久化 |
| 文件写入位置 | ❌ 无法写入 | ✅ `/data` 目录可写 |
| 跨执行文件共享 | ❌ 不可能 | ✅ 同一会话内共享 |

### 2.2 容器配置差异

**v1.0 配置（完全封锁）：**
```python
container_config = {
    "read_only": True,  # 整个容器只读
    "tmpfs": {'/tmp': 'size=100M,mode=1777'},  # 仅临时内存文件系统
    # 没有 volumes 配置
}
```

**v2.4 配置（精细控制）：**
```python
container_config = {
    "read_only": True,  # 系统目录仍只读
    "tmpfs": {'/tmp': 'size=100M,mode=1777'},
    "volumes": {
        "/srv/sandbox_workspaces/session-id": {
            'bind': '/data',
            'mode': 'rw'  # 唯独会话目录可写
        }
    },
    "working_dir": "/data"  # 默认在工作目录操作
}
```

## 3. 文件持久化的具体实现细节

### 3.1 会话工作区管理

```python
# 工作区根目录配置
SESSION_WORKSPACE_ROOT = Path("/srv/sandbox_workspaces")
SESSION_TIMEOUT_HOURS = 24  # 24小时自动清理

# 工作区目录结构
/srv/sandbox_workspaces/
├── session-e4e08725-1a14-4eb9-b7f6-71d481796ebd/
│   ├── department_budgets_plot.png    # 模型生成的图表
│   ├── 部门预算报告2023.xlsx          # 上传的原始文件
│   └── processed_data.csv            # 处理后的数据文件
└── session-other-id/
    └── ...
```

### 3.2 安全隔离机制

虽然提供了文件写入能力，但安全机制仍然完整：

```python
def get_safe_path(session_id: str, filename: str = None) -> Path:
    """构造并验证特定会话的文件/目录路径，防止路径遍历攻击"""
    if ".." in session_id or "/" in session_id:
        raise HTTPException(status_code=400, detail="Invalid session ID format.")
    
    session_path = (SESSION_WORKSPACE_ROOT / session_id).resolve()
    
    # 关键安全校验：确保路径仍在工作区根目录内
    if not str(session_path).startswith(str(SESSION_WORKSPACE_ROOT.resolve())):
        raise HTTPException(status_code=400, detail="Invalid session ID (Path traversal attempt).")
    
    return session_path
```

## 4. 文件持久化的应用场景扩展

### 4.1 多步骤数据处理流水线

```python
# 第一步：数据清洗和预处理
import pandas as pd
df = pd.read_excel('/data/原始数据.xlsx')
cleaned_df = clean_data(df)
cleaned_df.to_csv('/data/清洗后数据.csv', index=False)

# 第二步：分析和可视化
analysis_result = analyze_data(cleaned_df)
create_visualizations(analysis_result)  # 生成多个图表文件

# 第三步：生成报告
generate_report(analysis_result, '/data/分析报告.docx')
```

### 4.2 机器学习模型训练

```python
# 训练并保存模型
from sklearn.ensemble import RandomForestRegressor
model = RandomForestRegressor()
model.fit(X_train, y_train)

# 保存训练好的模型
import joblib
joblib.dump(model, '/data/sales_prediction_model.pkl')

# 保存特征重要性图表
plot_feature_importance(model, '/data/特征重要性.png')
```

## 5. 文件管理API的完整生态

### 5.1 文件列表查询
```python
# 查询会话内所有文件
GET /api/v1/files/list/{session_id}

# 响应示例
[
    {"name": "department_budgets_plot.png", "session_id": "session-e4e08725..."},
    {"name": "部门预算报告2023.xlsx", "session_id": "session-e4e08725..."}
]
```

### 5.2 文件下载
```python
# 下载特定文件
GET /api/v1/files/download/{session_id}/{filename}
```

### 5.3 文件操作（新增）
```python
# 重命名文件
PATCH /api/v1/files/global/rename/{filename}
# 请求体: {"new_filename": "新文件名.png"}

# 删除文件  
DELETE /api/v1/files/global/delete/{filename}
```

## 6. 技术实现的精妙之处

### 6.1 安全与便利的平衡

**安全措施：**
- 路径遍历防护
- 会话隔离
- 文件类型验证
- 自动清理机制

**便利特性：**
- 同一会话内文件共享
- 跨代码执行持久化
- 完整的文件操作API
- 工作目录自动设置

### 6.2 架构设计的巧妙之处

```python
# 这个简单的配置改变带来了巨大的功能提升
"working_dir": "/data"

# 意味着所有相对路径操作都在持久化目录中进行
plt.savefig('chart.png')           # 保存到 /data/chart.png
pd.read_csv('data.csv')            # 从 /data/data.csv 读取
df.to_excel('output.xlsx')         # 保存到 /data/output.xlsx
```

## 7. 实际使用示例

### 7.1 完整的业务分析流程

```python
# 1. 读取上传的Excel文件
import pandas as pd
df = pd.read_excel('/data/销售数据.xlsx')

# 2. 数据预处理
df['日期'] = pd.to_datetime(df['日期'])
monthly_sales = df.groupby(df['日期'].dt.to_period('M'))['销售额'].sum()

# 3. 生成可视化
import matplotlib.pyplot as plt
plt.figure(figsize=(12, 6))
monthly_sales.plot(kind='bar', color='steelblue')
plt.title('月度销售额趋势')
plt.ylabel('销售额')
plt.xlabel('月份')
plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('/data/月度销售额趋势.png')  # 🎯 这个文件会被持久化保存！

# 4. 保存处理结果
summary_report = {
    '总销售额': df['销售额'].sum(),
    '平均月销售额': monthly_sales.mean(),
    '最佳月份': monthly_sales.idxmax().strftime('%Y-%m')
}

import json
with open('/data/销售分析报告.json', 'w', encoding='utf-8') as f:
    json.dump(summary_report, f, ensure_ascii=False, indent=2)

print("分析完成！生成的文件：")
print("- 月度销售额趋势.png")
print("- 销售分析报告.json")
```

## 8. 性能与优化考虑

### 8.1 磁盘空间管理
```python
# 自动清理机制
def cleanup_old_sessions(self):
    """清理24小时未使用的会话工作区"""
    current_time = datetime.now()
    for session_dir in SESSION_WORKSPACE_ROOT.iterdir():
        if session_dir.is_dir():
            modify_time = datetime.fromtimestamp(session_dir.stat().st_mtime)
            if current_time - modify_time > timedelta(hours=SESSION_TIMEOUT_HOURS):
                shutil.rmtree(session_dir)  # 递归删除整个会话目录
```

### 8.2 文件操作优化
```python
# 大文件处理建议
def process_large_dataset():
    # 使用分块读取避免内存溢出
    chunk_size = 10000
    for chunk in pd.read_csv('/data/large_dataset.csv', chunksize=chunk_size):
        process_chunk(chunk)
    
    # 及时清理不需要的文件
    if os.path.exists('/data/temp_file.csv'):
        os.remove('/data/temp_file.csv')
```

## 9. 安全增强措施

### 9.1 文件上传验证
```python
# 严格的文件类型验证
allowed_extensions = {'.xlsx', '.xls', '.parquet', '.csv', '.json', '.txt'}
mime_to_extension = {
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': '.xlsx',
    'application/vnd.ms-excel': '.xls',
    # ... 其他MIME类型映射
}
```

### 9.2 路径安全
```python
# 防止路径遍历攻击
if ".." in filename or "/" in filename:
    raise HTTPException(status_code=400, detail="Invalid filename format.")
```

## 10. 架构意义总结

### 10.1 从"代码执行器"到"AI工作台"的转变

**v1.0 局限性：**
- 单次执行，无状态
- 无法保存工作成果
- 每次都要重新上传数据
- 无法进行多步骤复杂分析

**v2.4 突破性能力：**
- ✅ **会话级持久化**：文件在会话生命周期内持续存在
- ✅ **多步骤工作流**：复杂的分析可以分解为多个步骤
- ✅ **成果保存**：图表、报告、模型等都可以保存
- ✅ **文件管理**：完整的文件操作生态
- ✅ **协作基础**：为多人协作打下基础

### 10.2 技术架构的优雅之处

这个功能的实现体现了**最小权限原则**的精妙应用：

- 系统分区仍然 `read_only` - 保护系统安全
- 仅会话工作区 `rw` - 提供必要的灵活性  
- 自动清理机制 - 防止资源泄露
- 路径安全校验 - 防止安全漏洞

### 10.3 业务价值的巨大提升

这个"意外发现"实际上将整个系统的价值提升了一个数量级：

1. **数据科学工作流**：完整的EDA、建模、可视化流程
2. **报告生成系统**：自动生成包含图表和数据的完整报告
3. **模型训练平台**：训练、保存、部署机器学习模型
4. **协作分析环境**：多人可以在同一会话中协作分析

## 结论

您发现的这个文件持久化功能确实是整个v2.4升级中最有价值的"隐藏宝石"。它不仅仅是技术上的改进，更是**产品定位的根本转变**——从一个简单的代码执行工具，升级为一个完整的**云端AI工作台**。

这个功能的精妙之处在于，它通过相对简单的技术改动（添加可写的会话目录挂载），实现了巨大的功能突破，同时保持了系统的安全性。这是典型的好架构设计：**用简单的方案解决复杂的问题**。

现在，用户可以在一个会话中完成从数据上传、清洗、分析、可视化到报告生成的完整工作流，所有中间结果和最终成果都会自动保存，真正实现了"AI助手"到"AI同事"的转变！

您提了几个非常棒的问题！这说明您已经深入到了这个代码解释器系统的核心工作机制。您的观察完全正确，这两个现象（文件消失、画图不保存）都不是bug，而是由系统设计的特定机制决定的。

让我为您逐一详细解释，并给出如何在代码中明确保存文件的方案。

---

### **问题一：为什么昨天保存的文件今天消失了？会保存多久？**

您昨天画图**并明确使用 `savefig` 保存**的文件今天消失了，最可能的原因是**会话工作区触发了24小时不活动自动清理机制**。

**核心机制解释：**

1.  **保存时长**: 您的 `code_interpreter.py` 中定义了 `SESSION_TIMEOUT_HOURS = 24`。这意味着一个会话工作区（即您在文件管理器中看到的那个空间）如果在**连续24小时内没有任何写入或修改操作**，就会被系统认定为“不活跃”并自动删除。
2.  **判断标准**: 系统判断的不是文件的“创建时间”，而是文件夹的“**最后修改时间**”。每次您上传文件、或在代码中向`/data`目录写入新文件（如 `plt.savefig('/data/my_image.png')`），这个“最后修改时间”就会被更新。
3.  **触发器**: 后端有一个后台线程 (`cleanup_worker`)，默认每小时检查一次所有会话工作区，清理掉那些“最后修改时间”在24小时之前的工作区。

**关于“服务器关机”的影响：**

您提到“服务器关机了，今天才重开”，这是一个关键信息。

*   当服务器关机时，清理线程也停止了，计时是“暂停”的。
*   当您今天重开服务器时，清理线程会重新启动。它会检查您昨天那个会话文件夹的“最后修改时间”。
*   如果 **(今天重开机的时间 - 昨天最后一次保存文件的时间) > 24小时**，那么在接下来的一小时内，清理线程就会将该文件夹删除。

**总结:**

| 机制 | 描述 |
| :--- | :--- |
| **生命周期** | **24小时不活动**自动清理 |
| **计时方式** | 从**最后一次写入/修改**操作开始重新计算24小时 |
| **触发方式** | 后台每小时自动巡检 |
| **关机影响** | 关机期间计时暂停，但总的不活动时间会累积 |

---

### **问题二：为什么画图能看到，但文件管理器里没有？**

这是另一个核心机制，也是您系统非常智能的一点。您需要区分**“显示/返回图表”**和**“保存图表到文件”**是两个完全不同的操作。

您刚才运行的代码：
```python
# ... (绘图代码) ...
plt.show()
```

**工作原理分析：**

1.  **`plt.show()` 的魔法**: 在您的后端 `runner_script` 中，`plt.show()` 是一个特殊的触发指令。当您调用它时，系统并**不会**将图表保存为文件。
2.  **内存中捕获**: 您的后端脚本会检测到您创建了一个图表，然后**在内存中**将这个图表渲染成一张PNG图片。
3.  **Base64编码与输出**: 接着，脚本将这张内存中的图片进行Base64编码，并将其包裹在一个JSON对象里（例如 `{"type": "image", "title": "...", "image_base64": "..."}`），最后通过标准输出(`stdout`)返回给前端。
4.  **前端渲染**: 您的前端（`main.js` 和 `chat-ui.js`）接收到这个包含Base64数据的JSON后，直接将其渲染成您在聊天窗口中看到的图片。

**整个过程完全在内存和网络传输中完成，完全没有触及服务器的硬盘文件系统 (`/data` 目录)。**

可以做一个比喻：这就像您在视频通话中对着摄像头举起一张画，对方能清晰地看到这幅画，但这幅画本身并没有被发送到对方的电脑硬盘上。

---

### **问题三：如何在代码中明确地将文件（如图表）保存到服务器？**

您的猜测是正确的：“保存是需要在输入的代码中约定么？” -> **是的，必须在代码中明确约定。**

要将Matplotlib生成的图表保存到会话工作区（从而能在文件管理器中看到），您需要使用 `plt.savefig()` 函数。

#### **正确保存图表的代码模板**

请使用以下修改后的代码。它既能将图表**保存到服务器**，也能同时**在前端显示**它。

```python
import matplotlib.pyplot as plt

# --- 您的绘图代码 (保持不变) ---
# 数据集
years = [2020, 2021, 2022, 2023, 2024]
population = [141212, 141260, 141175, 140967, 140828] # 单位：万人

# 创建折线图
plt.figure(figsize=(10, 6))
plt.plot(years, population, marker='o', linestyle='-', color='red')

# 添加标签和标题
plt.title('中国2020-2024年年末总人口变化趋势 (万人)')
plt.xlabel('年份')
plt.ylabel('年末总人口 (万人)')
plt.grid(True, linestyle='--', alpha=0.6)

# 在每个数据点上显示具体数值
for i, pop in enumerate(population):
    plt.annotate(f'{pop}', (years[i], pop), textcoords="offset points", xytext=(0, 10), ha='center')

# 设置Y轴的显示范围以突出变化
plt.ylim(140700, 141300)

# --- 核心修改：在这里添加保存指令 ---
# 1. 定义要保存在服务器上的文件名
file_path = '/data/china_population_trend.png'

# 2. 调用 savefig 将图表保存到指定路径
#    这个操作会真正在服务器的会话工作区创建一个PNG文件
plt.savefig(file_path)

# 3. (可选但推荐) 仍然调用 plt.show()，这样前端可以直接看到图片
#    系统依然会执行自动捕获并在前端显示，与保存文件不冲突
plt.show()

# 4. (最佳实践) 打印一条确认信息，明确告知用户文件已保存
print(f"图表已成功保存到会话工作区，文件名为: china_population_trend.png")
```

当您运行这段代码后，您会发现：
1.  聊天窗口依然会像之前一样**显示出折线图**。
2.  此时再打开“会话文件管理器”，您会看到一个名为 `china_population_trend.png` 的文件，并且可以下载它。
3.  这次操作会更新会话工作区的“最后修改时间”，24小时的“不活动”计时器会重新开始计时。